1. Git Basic
	$ git init
	$ git add 
		put all the changes to be committed to the Stage
	$ git commit -m "message"
		commit all the changes to the branch

	Working directory
	Repository(/.git): -----> Stage
					   -----> master

	$ git status
	# tell us the files conditions
	# example: On branch master
		Changes not staged for commit:
	  	(use "git add <file>..." to update what will be committed)
	  	(use "git checkout -- <file>..." to discard changes in working directory)

		modified:   VersionControlPractice.txt

		no changes added to commit (use "git add" and/or "git commit -a")

	$ git diff
	# to compare working directory content with Stage (content on Stage is what has been added but not committed)

	$ git diff --cache
	# to compare Stage with master

	$ git diff HEAD
	# compare content in Stage with latest version in .git

	$ git log
	# to check historical record of version control
	# example:
		commit aecd058c33609e26710535df568b6d0ffe9a1aa5
		Author: YifengGuo <gyf940517@gmail.com>
		Date:   Tue Oct 24 23:56:32 2017 -0400

		    third version append GPL

		commit 54b0663e20d87f90aad2d527a2397f36e537fcc3
		Author: YifengGuo <gyf940517@gmail.com>
		Date:   Tue Oct 24 23:52:01 2017 -0400

		    second version

		commit 6ff3753f5e893df87ecb11ca71bceb4481df3d6e
		Author: YifengGuo <gyf940517@gmail.com>
		Date:   Tue Oct 24 23:32:45 2017 -0400

		    first version

	$ git log --pretty=oneline
	# have a prettified look on the historical log
		aecd058c33609e26710535df568b6d0ffe9a1aa5 third version append GPL
		54b0663e20d87f90aad2d527a2397f36e537fcc3 second version
		6ff3753f5e893df87ecb11ca71bceb4481df3d6e first version

	6ff3753f5e893df87ecb11ca71bceb4481df3d6e is a huge hex number generated by SHA1 to avoid duplicate commit id 
	during teamwork

2. Reset to historical version
	2.1 HEAD point to current/latest version
		HEAD^: last version
		HEAD^^: last version of last version
		HEAD~n: last nth version

	2.2 git reset
		$ git reset --hard HEAD^ (parameter hard will be covered later)
		# reset current version to last version

		$ cat xxx.file
		# take a look at the file of latest version

		$ git reflog  # check all the historical versions
		$ git reset --hard commit_id
		# give us a chance to reset to any version before even we have reset to some older version


	2.3. Manage changes: Git is designed to manage changes instead of files
			git add will only put content in working directory into Stage
			change -> git  add ...  ->  change -> git commit -m "..."
			then secont change will not be put into Stage, we could add
			multiple times and then commit altogether

	2.4 Discard changes
		$ git checkout -- file_name
		# could discard changes in working directory
			case 1: file has not been put to Stage after changes (not added)
			case 2: file has been put to Stage and bad changes happen after file is in the Stage
					but bad changes have not been added
			both cases, git checkout will put file back to latest git commit or git add contidion

			case 3: bad changes existed in the file and the file was added to Stage but not committed
			$ git reset HEAD file_name
			# git reset can not only reset to historical versions, but also can discard changes in the Stage
			# and put all the changes back to working directory
			# then if we need to discard changes in the working directory, we can use git checkout -- file_name


			case 4: bad changes existed in the file and the file was added and also commited to branch
			        but has not been pushed to remote repo (not pushed)
			$ git reflog
			# to find last good version
			$ git reset --hard commit_id
			# reset to that good version
			# then the content in the /.git(repo) is good

			However, if we committed bad changes and push it to the remote repo, the consequence is serious!!!!

	2.5 Remove files: in Git, removing files is also a kind of change
			we remove the file by rm file_name or directly delete it,and git status told us the file is 
			changed since working directory is not corresponding with .git. So we have two choices here:
				choice 1: we do want to delete the file, so we need to remove it from .git as well:
					$ git rm file_name 
					# remove files in working directory and Stage
					$ git commit -m "remove xxx file" 
					# after commit, the file in .git will be removed as well
					# then the file is removed from .git
					# if we call git rm file_name by mistake, use git reset --hard VERSION_ID back to where we want
				choice 2: we delete the file by mistake, and we want to retrieve the file. Then git can help us.
					$ git checkout -- file_name
					# Then the wrongly removed file is retrieved with its latest version to local 
					# So actually "git checkout" is to replace files in working directory with files in the .git

3. Remote Repository
	3.1 Initialize SSH Key for your PC with Github
		step 1: init SSH Key (if the pc does not have .ssh/)
			$ ssh-keygen -t rsa -C "youremail@example.com"
			# then we will have a .ssh/ directory which contains id_rsa and id_rsa.pub
			# id_rsa is private key which cannot be revealed to others
			# id_rsa.pub is public key which can be revealed to others
		step 2: Log in to Github and access to SSH settings
				Name a title for the key
				Add SSH Key with your id_rsa.pub
	Then each time when use this computer clone or push contents from or to this Github address, we 
	do not need to input username and password for the Github knows that I am the authenticate user 
	of this address

	3.2 new remote repo

	3.2 git clone (https and SSH)

4. Branch Management
			