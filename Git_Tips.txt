1. Git Basic
	$ git init
	$ git add 
		put all the changes to be committed to the Stage
	$ git commit -m "message"
		commit all the changes to the branch

	Working directory
	Repository(/.git): -----> Stage
					   -----> master

	$ git status
	# tell us the files conditions
	# example: On branch master
		Changes not staged for commit:
	  	(use "git add <file>..." to update what will be committed)
	  	(use "git checkout -- <file>..." to discard changes in working directory)

		modified:   VersionControlPractice.txt

		no changes added to commit (use "git add" and/or "git commit -a")

	$ git diff
	# to compare working directory content with Stage (content on Stage is what has been added but not committed)

	$ git diff --cache
	# to compare Stage with master

	$ git diff HEAD
	# compare content in Stage with latest version in .git

	$ git log
	# to check historical record of version control
	# example:
		commit aecd058c33609e26710535df568b6d0ffe9a1aa5
		Author: YifengGuo <gyf940517@gmail.com>
		Date:   Tue Oct 24 23:56:32 2017 -0400

		    third version append GPL

		commit 54b0663e20d87f90aad2d527a2397f36e537fcc3
		Author: YifengGuo <gyf940517@gmail.com>
		Date:   Tue Oct 24 23:52:01 2017 -0400

		    second version

		commit 6ff3753f5e893df87ecb11ca71bceb4481df3d6e
		Author: YifengGuo <gyf940517@gmail.com>
		Date:   Tue Oct 24 23:32:45 2017 -0400

		    first version

	$ git log --pretty=oneline
	# have a prettified look on the historical log
		aecd058c33609e26710535df568b6d0ffe9a1aa5 third version append GPL
		54b0663e20d87f90aad2d527a2397f36e537fcc3 second version
		6ff3753f5e893df87ecb11ca71bceb4481df3d6e first version

	6ff3753f5e893df87ecb11ca71bceb4481df3d6e is a huge hex number generated by SHA1 to avoid duplicate commit id 
	during teamwork

2. Reset to historical version
	2.1 HEAD point to current/latest version
		HEAD^: last version
		HEAD^^: last version of last version
		HEAD~n: last nth version

	2.2 git reset
		$ git reset --hard HEAD^ (parameter hard will be covered later)
		# reset current version to last version

		$ cat xxx.file
		# take a look at the file of latest version

		$ git reflog  # check all the historical versions
		$ git reset --hard commit_id
		# give us a chance to reset to any version before even we have reset to some older version


	2.3. Manage changes: Git is designed to manage changes instead of files
			git add will only put content in working directory into Stage
			change -> git  add ...  ->  change -> git commit -m "..."
			then secont change will not be put into Stage, we could add
			multiple times and then commit altogether

	2.4 Discard changes
		$ git checkout -- file_name
		# could discard changes in working directory
			case 1: file has not been put to Stage after changes (not added)
			case 2: file has been put to Stage and bad changes happen after file is in the Stage
					but bad changes have not been added
			both cases, git checkout will put file back to latest git commit or git add contidion

			case 3: bad changes existed in the file and the file was added to Stage but not committed
			$ git reset HEAD file_name
			# git reset can not only reset to historical versions, but also can discard changes in the Stage
			# and put all the changes back to working directory
			# then if we need to discard changes in the working directory, we can use git checkout -- file_name


			case 4: bad changes existed in the file and the file was added and also commited to branch
			        but has not been pushed to remote repo (not pushed)
			