1. Git Basic
	$ git init
	$ git add 
		put all the changes to be committed to the Stage
	$ git commit -m "message"
		commit all the changes to the branch

	Working directory
	Repository(/.git): -----> Stage
					   -----> master

	$ git status
	# tell us the files conditions
	# example: On branch master
		Changes not staged for commit:
	  	(use "git add <file>..." to update what will be committed)
	  	(use "git checkout -- <file>..." to discard changes in working directory)

		modified:   VersionControlPractice.txt

		no changes added to commit (use "git add" and/or "git commit -a")

	$ git diff
	# to compare working directory content with Stage (content on Stage is what has been added but not committed)

	$ git diff --cache
	# to compare Stage with master

	$ git diff HEAD
	# compare content in Stage with latest version in .git

	$ git log
	# to check historical record of version control
	# example:
		commit aecd058c33609e26710535df568b6d0ffe9a1aa5
		Author: YifengGuo <gyf940517@gmail.com>
		Date:   Tue Oct 24 23:56:32 2017 -0400

		    third version append GPL

		commit 54b0663e20d87f90aad2d527a2397f36e537fcc3
		Author: YifengGuo <gyf940517@gmail.com>
		Date:   Tue Oct 24 23:52:01 2017 -0400

		    second version

		commit 6ff3753f5e893df87ecb11ca71bceb4481df3d6e
		Author: YifengGuo <gyf940517@gmail.com>
		Date:   Tue Oct 24 23:32:45 2017 -0400

		    first version

	$ git log --pretty=oneline
	# have a prettified look on the historical log
		aecd058c33609e26710535df568b6d0ffe9a1aa5 third version append GPL
		54b0663e20d87f90aad2d527a2397f36e537fcc3 second version
		6ff3753f5e893df87ecb11ca71bceb4481df3d6e first version

	6ff3753f5e893df87ecb11ca71bceb4481df3d6e is a huge hex number generated by SHA1 to avoid duplicate commit id 
	during teamwork

2. Reset to historical version
	2.1 HEAD point to current/latest version
		HEAD^: last version
		HEAD^^: last version of last version
		HEAD~n: last nth version

	2.2 git reset
		$ git reset --hard HEAD^ (parameter hard will be covered later)
		# reset current version to last version

		$ cat xxx.file
		# take a look at the file of latest version

		$ git reflog  # check all the historical versions
		$ git reset --hard commit_id
		# give us a chance to reset to any version before even we have reset to some older version


	2.3. Manage changes: Git is designed to manage changes instead of files
			git add will only put content in working directory into Stage
			change -> git  add ...  ->  change -> git commit -m "..."
			then secont change will not be put into Stage, we could add
			multiple times and then commit altogether

	2.4 Discard changes
		$ git checkout -- file_name
		# could discard changes in working directory
			case 1: file has not been put to Stage after changes (not added)
			case 2: file has been put to Stage and bad changes happen after file is in the Stage
					but bad changes have not been added
			both cases, git checkout will put file back to latest git commit or git add contidion

			case 3: bad changes existed in the file and the file was added to Stage but not committed
			$ git reset HEAD file_name
			# git reset can not only reset to historical versions, but also can discard changes in the Stage
			# and put all the changes back to working directory
			# then if we need to discard changes in the working directory, we can use git checkout -- file_name


			case 4: bad changes existed in the file and the file was added and also commited to branch
			        but has not been pushed to remote repo (not pushed)
			$ git reflog
			# to find last good version
			$ git reset --hard commit_id
			# reset to that good version
			# then the content in the /.git(repo) is good

			However, if we committed bad changes and push it to the remote repo, the consequence is serious!!!!

	2.5 Remove files: in Git, removing files is also a kind of change
			we remove the file by rm file_name or directly delete it,and git status told us the file is 
			changed since working directory is not corresponding with .git. So we have two choices here:
				choice 1: we do want to delete the file, so we need to remove it from .git as well:
					$ git rm file_name 
					# remove files in working directory and Stage
					$ git commit -m "remove xxx file" 
					# after commit, the file in .git will be removed as well
					# then the file is removed from .git
					# if we call git rm file_name by mistake, use git reset --hard VERSION_ID back to 
                                        # where we want
				choice 2: we delete the file by mistake, and we want to retrieve the file. Git can help us.
					$ git checkout -- file_name
					# Then the wrongly removed file is retrieved with its latest version to local 
					# So actually "git checkout" is to replace files in working directory with files in 
                                        # the .git

3. Remote Repository
	3.1 Initialize SSH Key for your PC with Github
		step 1: init SSH Key (if the pc does not have .ssh/)
			$ ssh-keygen -t rsa -C "youremail@example.com"
			# then we will have a .ssh/ directory which contains id_rsa and id_rsa.pub
			# id_rsa is private key which cannot be revealed to others
			# id_rsa.pub is public key which can be revealed to others
		step 2: Log in to Github and access to SSH settings
				Name a title for the key
				Add SSH Key with your id_rsa.pub
	Then each time when use this computer clone or push contents from or to this Github address, we 
	do not need to input username and password for the Github knows that I am the authenticate user 
	of this address

	3.2 new remote repo

	3.2 git clone (https and SSH)

4. Branch Management 
	4.1 Git will construct all commits as a timeline, and there is only one timeline called master if no other branch.
		HEAD actually is pointing to master, and master is pointing to latest commit.
					   HEAD
					    | 
					   \ /
					  master
					    |
					   \ /
		V1   -----  V2    ------   V3
		And each time we commit, master will advance forward by one step

	4.2 Initialize and manage new branch

		4.2.1 Initialize a new branch
		$ git checkout -b dev
		# the command is to initialize and switch to a new branch 'dev'
		# this cmd equals:
		# $ git branch dev
		# $ git checkout dev

		4.2.2 examine currently used branches
		$ git branch # list all branches
		# result:
		  * dev
		    master
		* represents currently used branch


					         master
					           |
					          \ /
			V1   -----  V2    ------   V3
                                                   / \
                                                    |
                                                   dev
                                                   / \
                                                    |
                                                   HEAD
	    4.2.3 merge branches
	    	 Assume we did some changes on dev branch and commit the changes
	    	 Then we change branch back to master, we would find content on 
	    	 master has no change, for we did not commit any change on master

	    	before merge:

					          HEAD
					            |
					           \ /
					          master
					            |
					           \ /
			V1   -----  V2    ------   V3  -------   V4
							         / \
							          |
							         dev

	        So we need to merge result on dev with master
	        $ git merge dev
	        # git merge branch_name:  is to merge chosen
	        # branch with current(HEAD_pointed) branch

	        after merge:

							         HEAD
							          |
							         \ /
							       master
							          |
							         \ /
			V1   -----  V2    ------   V3  -------   V4
							         / \
							          |
							         dev

	    4.2.4 delete useless branch
	    	after merging branches, some branch(es) may become
	    	useless, then we can directly delete them.

	    	$ git branch -d dev
	    	# delete dev branch

	    	after deleting dev
							        HEAD
							          |
							         \ /
							        master
							          |
							         \ /
			V1   -----  V2    ------   V3  -------   V4


	        After accomplishing the task on dev, then make master point to dev's current commit, 
	        the merge process is done simply.
	        Then we can remove dev branch and after that we again have only one branch master which
	        points to the latest commit
	        $ git branch
	        * master



	    4.2.5 Summary
	    	$ git branch # examine branches
	    	$ git branch <branch_name> # initialize new branch
	    	$ git checkout <branch_name> # switch to chosen branch
	    	$ git checkout -b <branch_name> # initialize + switch to new branch
	    	$ git merge <branch_name> # merge chosen branch with current (HEAD_pointed) branch
	    	$ git branch -d <branch_name> # remove chosen branch

	4.3 Handle Conflicts
	Assume we have a file called test_for_conflict_handle.txt
	and have some content created by master at very beginning
		4.3.1 initialize a new branch
			$ git checkout -b 'feature1'
			# and then create something new at the end of file
			$ git add file_name.txt
			$ git commit -m "changed by feature1"

		4.3.2 switch back to master and make some changes
			$ git checkout master
			# when switch back to master, git will notify us
			# that Switched to branch 'master'
			# Your branch is ahead of 'origin/master' by 1 commit.
            # (use "git push" to publish your local commits)

            # at this moment we cannot see changes made by feature1
            # then make some change at the end of file
            $ git add file_name.txt
            $ git commit -m "changed by master"

        4.3.3 conflict detected
        	# now master and feature have latest commit on their own branch
        	# it is like:
        							HEAD
							          |
							         \ /
							        master
							          |
							         \ /
			V1   -----  V2    ------   V3  -------   V4
						    |
						    |---------   v4`
							         / \
							          |
							       feature1
            # if we try to merge master with feature1 now
            $ git merge feature1                                          
        	# the git now will report conflict:
        	# Auto-merging file_name.txt
            # CONFLICT (content): Merge conflict in file_name.txt
            # Automatic merge failed; fix conflicts and then commit the result.
            # and 'git status' can also tell us the conflict info

        4.3.4 examine and handle conflict
        	$ cat file_name.txt (subl file_name.txt)
        	# the git will show conflict position to us:
        	# flict_handle.txt 
				Created by master
				<<<<<<< HEAD
				changed by master 2nd time
				=======
				Changed by branch feature1
				>>>>>>> feature1
			# <<<<<<<, ========, >>>>>>>> can mark out different branches content
			# and we can amend conflict content to uniformed content manually

			# after amending conflict content
			$ git add file_name.txt
			# git commit -m "conflict fixed"

			# now the timeline is like:
										HEAD
										  |
										 \ /
										master
										  |
										 \ /
			V1   -----  V2    ------   V3  -------   V4   ---------- v5
						    |                             |
						    |---------   v4`  ------------
								 / \
								  |
								feature1

            # we can also use
            $ git log --graph --pretty=oneline --abbrev-commit
            # to check branch info

				*   490aba7 conflict fixed
				|\  
				| * 9284363 feature1 change 1st time
				* | 647b6b7 master change 2nd time
				|/  

		4.3.5 remove feature1
			$ git branch -d feature1

	4.4 Branch Management Strategy

		4.4.1 --no--ff Merge Mode
			Git will use Fast forward mode to merge branches by default.

			But under this mode, if we delete branch, the info of branch
	  		will be discarded as well.

		    If we force to disable Fast forward mode, Git will initialize a
		    new commit while merging and we can checkout historical info of
			branches from log (--no-ff)

			# initialize and switch to branch dev
			$ git checkout -b dev

			# do something change to file_name.txt
			$ git add file_name.txt
			$ git commit -m "modified by dev"

			# switch back to master
			$ git checkout master

			# merge master and dev by --no-ff Mode
			# because under --no-ff mode, merge will initialize a new commit
			# so we need to explictly name a commit with message m
			$ git merge commit -m "merge by --no-ff" dev

			# Merge made by the 'recursive' strategy.
 			# local_repo_management/test_branch_management_strategy.txt | 4 +++-
 			# 1 file changed, 3 insertions(+), 1 deletion(-)

 			# after merging master with dev by --no-ff mode
 			# we can checkout log to see how the mode works

            *   4ad595b merge with no-ff
            |\  
            | * ff2d105 amended by branch dev
            |/  


    4.5 Bug Branch
    	Use case:
    			We can use a branch to fix a certain bug we meet during development
    			After we fix the bug, then we merge the auxiliary branch with master
    			and then remove aux branch.
    			However, assume we are working on the dev branch, and we need to fix
    			a bug named issue-101. But at this moment we cannot commit out work
    			since we haven't finished it yet. And the bug fix job is urgent and 
    			cannot wait until we complte the work. How to satisfy both issues?

    			Git has a utility called stash which can store current work 
    			for future continuation. After stashing, we can checkout to
    			other branch to do other task like fixing a bug we need.

    			$ git stash
                # Saved working directory and index state WIP on dev: 8b548c9 dev first commit
                # HEAD is now at 8b548c9 dev first commit
                # now if we call git status, we can find working directory is clean

                # switch back to master
                # and inialize special branch to fix bug
                $ git checkout master
                $ git checkout -b issue-101

                # fix the bug
                $ git add bug_fixed_file_name
                $ git commit -m "fix bug 101"

                # switch back to master and merge master with issue-101, then delete issue-101
                $ git checkout master
                $ git merge --no-ff -m "merged bug fix 101" issue-101
                # Merge made by the 'recursive' strategy.
                # local_repo_management/fix_bug.txt | 0
                # 1 file changed, 0 insertions(+), 0 deletions(-)
                $ git branch -d issue-101 # delete aux branch

                # switch back to dev and continue the stashed incomplete work
                $ git checkout dev
                # to checkout stashed work, use git stash list
                $ git stash list
                # stash@{0}: WIP on dev: 8b548c9 dev first commit

                # two way to retrieve the stashed work
                # 1. git stash apply + git stash drop to retrieve work and delete stash
                # 2. git stash pop  --> directly retrieve and delete stash
                $ git stash pop 
                On branch dev
                # Changes not staged for commit:
               		 (use "git add <file>..." to update what will be committed)
                #	 (use "git checkout -- <file>..." to discard changes in working directory)

	            # 		 modified:   test_for_stash_bug_fix.txt

                # no changes added to commit (use "git add" and/or "git commit -a")
                # Dropped refs/stash@{0} (c806584683fc2bf1be2d406a352bd5aa77c98c0e)

                $ git stash list
                # now the stash is empty

                # we can stash multiple works
                # to retrieve particular work:
                $ git stash appply  stash@{0} # {stash_id}


    4.6 Force delete unmerged branch

    	If we want to delete an unmerged branch like a feature
    	$ git branch -d feature
        # error: The branch 'feature' is not fully merged.
        # If you are sure you want to delete it, run 'git branch -D feature'.

        $ git branch -D feature
        # to force delete feature







